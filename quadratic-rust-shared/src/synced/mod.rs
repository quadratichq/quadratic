use bytes::Bytes;
use chrono::NaiveDate;
use object_store::ObjectStore;
use serde::Deserialize;
use std::{collections::HashMap, sync::Arc};

use crate::{
    SharedError,
    arrow::object_store::{list_objects, upload_multipart},
    error::Result,
};

pub mod mixpanel;

const DATE_FORMAT: &str = "%Y-%m-%d";

/// Convert an error to a SharedError.
fn synced_error(e: impl ToString) -> SharedError {
    SharedError::Synced(e.to_string())
}

/// Parse a date from a string.
fn parse_file_date(string_date: &str) -> Result<NaiveDate> {
    // remove .parquet from the end of the string
    let string_date = string_date.to_ascii_lowercase().replace(".parquet", "");
    let date = NaiveDate::parse_from_str(&string_date, DATE_FORMAT).map_err(synced_error)?;
    Ok(date)
}

/// Get the date from the location of the file.
fn get_date_from_location(location: &str) -> Result<NaiveDate> {
    if !location.to_ascii_lowercase().contains(".parquet") {
        return Err(synced_error("Not a parquet file"));
    }

    let parts = location.split('/').collect::<Vec<&str>>();
    let string_date = parts
        .last()
        .ok_or_else(|| synced_error("No date found in location"))?;

    parse_file_date(string_date)
}

/// Get the last date of the objects in the object store using the date in the location.
pub async fn get_last_date_processed(
    object_store: &Arc<dyn ObjectStore>,
    prefix: Option<&str>,
) -> Result<Option<NaiveDate>> {
    let objects = list_objects(object_store, prefix).await?;
    let last_date = objects
        .iter()
        .flat_map(|o| get_date_from_location(o.location.as_ref()))
        .collect::<Vec<NaiveDate>>()
        .iter()
        .max()
        .cloned();

    Ok(last_date)
}

/// Upload multiple parquet files to S3 from pre-generated bytes
///
/// Each key is a date, and the value is the parquet file bytes.
/// Returns the number of files uploaded.
pub async fn upload(
    object_store: &Arc<dyn ObjectStore>,
    prefix: &str,
    data: HashMap<String, Bytes>,
) -> Result<usize> {
    let num_files = data.len();

    for (key, parquet_bytes) in data.into_iter() {
        let file_name = format!("{}/{}.parquet", prefix, key);

        upload_multipart(object_store, &file_name, &parquet_bytes)
            .await
            .map_err(|e| {
                SharedError::Synced(format!(
                    "Failed to upload parquet file {} to S3: {}",
                    file_name, e
                ))
            })?;
    }

    Ok(num_files)
}

pub fn deserialize_int_to_bool<'de, D>(deserializer: D) -> Result<Option<bool>, D::Error>
where
    D: serde::Deserializer<'de>,
{
    match Option::<u32>::deserialize(deserializer)? {
        Some(0) => Ok(Some(false)),
        Some(_) => Ok(Some(true)),
        None => Ok(None),
    }
}
