generator client {
    provider      = "prisma-client-js"
    binaryTargets = ["native", "linux-arm64-openssl-3.0.x", "debian-openssl-3.0.x"]
}

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

model User {
    id                  Int               @id @default(autoincrement())
    auth0Id             String            @unique @map("auth0_id")
    email               String            @unique @map("email")
    eduStatus           EduStatus?        @map("edu_status")
    /**
     * @deprecated We now store this info on the Team as `onboardingResponses`
     */
    onboardingResponses Json?             @map("onboarding_responses")
    ownedFiles          File[]            @relation(name: "OwnerRelation")
    createdFiles        File[]            @relation(name: "CreatorRelation")
    QFeedback           QFeedback[]
    UserTeamRole        UserTeamRole[]
    UserFileRole        UserFileRole[]
    AnalyticsAIChat     AnalyticsAIChat[]
    AICost              AICost[]
    UserBudgetLimit     UserBudgetLimit[]

    // JSON value used for key/value data storage about the user
    // We keep track of the shape of this object in typescript on the server & client
    clientDataKv  Json            @default("{}") @map("client_data_kv")
    ScheduledTask ScheduledTask[]

    // AI Settings
    aiRules     String?  @map("ai_rules") // User-specific AI rules/instructions
    aiLanguages String[] @default([]) @map("ai_languages") // Empty = no preference, non-empty = explicit preferences

    @@index([auth0Id])
    @@index([email])
}

enum EduStatus {
    INELIGIBLE
    // ELIGIBLE
    ENROLLED
    // NOT_ENROLLED
}

enum LinkPermission {
    NOT_SHARED
    READONLY
    EDIT
}

// TODO Properly configure camelCase <-> snake_case
model File {
    id          Int       @id @default(autoincrement())
    uuid        String    @unique @default(uuid())
    name        String
    thumbnail   String? // S3FileKey
    createdDate DateTime  @default(now()) @map("created_date")
    updatedDate DateTime  @default(now()) @map("updated_date")
    deleted     Boolean   @default(false)
    deletedDate DateTime? @map("deleted_date")
    // Binary file contents
    contents    Bytes? // unused to delete

    // This is recorded when the file is created and never changes after that
    creator       User @relation(name: "CreatorRelation", fields: [creatorUserId], references: [id])
    creatorUserId Int  @map("creator_user_id")

    // This is where we differentiate between who owns a file: an individual
    // user or a team. These two are mutually exclusive, i.e. you should only
    // ever have an `owner` or `team` but never both.
    //
    // This allows files to be "moved" between individual users, from a team to
    // a user, or a user to a team.
    ownerUser   User? @relation(name: "OwnerRelation", fields: [ownerUserId], references: [id])
    ownerUserId Int?
    ownerTeam   Team  @relation(fields: [ownerTeamId], references: [id])
    ownerTeamId Int   @map("owner_team_id")

    publicLinkAccess LinkPermission    @default(NOT_SHARED) @map("public_link_access")
    timezone         String?           @map("timezone")
    times_updated    Int               @default(1) // unused to delete
    version          String? // unused to delete
    FileCheckpoint   FileCheckpoint[]
    UserFileRole     UserFileRole[]
    FileInvite       FileInvite[]
    AnalyticsAIChat  AnalyticsAIChat[]
    AICost           AICost[]
    ScheduledTask    ScheduledTask[]

    @@index([uuid])
    @@index([ownerTeamId])
    @@index([id, ownerTeamId])
}

model FileCheckpoint {
    // Unique Identifiers
    id               Int      @id @default(autoincrement())
    file             File     @relation(fields: [fileId], references: [id])
    fileId           Int      @map("file_id")
    sequenceNumber   Int      @map("sequence_number")
    // Checkpoint Data
    s3Bucket         String   @map("s3_bucket")
    s3Key            String   @map("s3_key")
    version          String // Quadratic file version
    transactionsHash String?  @map("transactions_hash") // Hash for duplicate detection
    // Metadata
    timestamp        DateTime @default(now())

    @@unique([fileId, sequenceNumber])
    @@index([fileId, sequenceNumber])
    @@index([fileId, transactionsHash])
}

enum SubscriptionStatus {
    TRIALING
    ACTIVE
    INCOMPLETE
    INCOMPLETE_EXPIRED
    PAST_DUE
    CANCELED
    UNPAID
    PAUSED
}

enum PlanType {
    FREE
    PRO
    BUSINESS
}

model Team {
    id           Int            @id @default(autoincrement())
    uuid         String         @unique @default(uuid())
    name         String
    picture      String? // S3FileKey
    createdDate  DateTime       @default(now()) @map("created_date")
    UserTeamRole UserTeamRole[]
    TeamInvite   TeamInvite[]
    File         File[]
    Connection   Connection[]
    AICost       AICost[]

    // Onboarding
    onboardingComplete  Boolean? @default(false) @map("onboarding_complete") // null = legacy, do not gate, false = new, gate, true = completed
    onboardingResponses Json?    @map("onboarding_responses")

    // Billing
    stripeCustomerId                    String?             @unique @map("stripe_customer_id")
    stripeSubscriptionId                String?             @unique @map("stripe_subscription_id")
    stripeSubscriptionStatus            SubscriptionStatus? @map("stripe_subscription_status")
    stripeCurrentPeriodStart            DateTime?           @map("stripe_current_period_start")
    stripeCurrentPeriodEnd              DateTime?           @map("stripe_current_period_end")
    stripeSubscriptionLastUpdated       DateTime?           @map("stripe_subscription_last_updated")
    stripeSubscriptionRetentionCouponId String?             @map("stripe_subscription_retention_coupon_id")
    stripeOverageItemId                 String?             @map("stripe_overage_item_id")
    stripeOverageBilledCents            Int                 @default(0) @map("stripe_overage_billed_cents")
    stripeOverageBilledPeriodStart      DateTime?           @map("stripe_overage_billed_period_start")

    // Plan information
    planType                    PlanType?            @map("plan_type")
    allowOveragePayments        Boolean              @default(false) @map("allow_overage_payments") // Business plan only
    teamMonthlyBudgetLimit      Float?               @map("team_monthly_budget_limit") // Total team budget in dollars

    UserBudgetLimit             UserBudgetLimit[]

    // Key/value storage used by Quadratic client on the Team.
    // It remembers things like closing the onboarding banner.
    // Use for client-specific data that is not useful to the server or other services
    clientDataKv Json @default("{}") @map("client_data_kv")

    // Settings
    settingAnalyticsAi        Boolean @default(true) @map("setting_analytics_ai")
    settingShowConnectionDemo Boolean @default(true) @map("setting_show_connection_demo")
    aiRules                   String? @map("ai_rules") // Team-specific AI rules/instructions

    // SSH Keys
    sshPrivateKey Bytes?
    sshPublicKey  Bytes?

    @@index([uuid])
}

enum TeamRole {
    OWNER
    EDITOR
    VIEWER
}

enum ConnectionType {
    POSTGRES
    MYSQL
    MSSQL
    SNOWFLAKE
    BIGQUERY
    COCKROACHDB
    MARIADB
    NEON
    SUPABASE
    MIXPANEL
    GOOGLE_ANALYTICS
    PLAID
}

model Connection {
    // Generic details
    id                  Int       @id @default(autoincrement())
    uuid                String    @unique @default(uuid()) // used in URLs
    createdDate         DateTime  @default(now()) @map("created_date")
    updatedDate         DateTime  @default(now()) @map("updated_date")
    archived            DateTime?
    name                String
    team                Team      @relation(fields: [teamId], references: [id])
    teamId              Int       @map("team_id")
    semanticDescription String?   @map("semantic_description")
    // secretArn       String // AWS Secret Manager ARN

    // Type-specific details
    type             ConnectionType
    typeDetails      Bytes // InitializationVector:Cyphertext(JSON)
    SyncedConnection SyncedConnection?
}

enum SyncedConnectionStatus {
    ACTIVE
    INACTIVE
    DELETED
}

enum SyncedConnectionLogStatus {
    PENDING
    RUNNING
    COMPLETED
    FAILED
}

model SyncedConnection {
    id                  Int                    @id @default(autoincrement())
    connectionId        Int                    @unique @map("connection_id")
    connection          Connection             @relation(fields: [connectionId], references: [id])
    percentCompleted    Int                    @default(0) @map("percent_completed")
    status              SyncedConnectionStatus @default(ACTIVE) @map("status")
    updatedDate         DateTime               @default(now()) @map("updated_date")
    SyncedConnectionLog SyncedConnectionLog[]

    @@index([status])
}

model SyncedConnectionLog {
    id                 Int                       @id @default(autoincrement())
    syncedConnectionId Int                       @map("synced_connection_id")
    syncedConnection   SyncedConnection          @relation(fields: [syncedConnectionId], references: [id])
    runId              String                    @map("run_id")
    syncedDates        DateTime[]                @default([]) @map("synced_dates") @db.Date
    status             SyncedConnectionLogStatus @default(PENDING) @map("status")
    error              String?                   @map("error")
    createdDate        DateTime                  @default(now()) @map("created_date")

    @@index([syncedConnectionId])
    @@index([status])
    @@index([runId, createdDate(sort: Desc)])
    @@index([createdDate(sort: Desc)])
}

model UserTeamRole {
    id          Int      @id @default(autoincrement())
    userId      Int      @map("user_id")
    teamId      Int      @map("team_id")
    user        User     @relation(fields: [userId], references: [id])
    team        Team     @relation(fields: [teamId], references: [id])
    role        TeamRole
    createdDate DateTime @default(now()) @map("created_date")

    @@unique([userId, teamId])
}

model TeamInvite {
    id          Int      @id @default(autoincrement())
    email       String
    teamId      Int      @map("team_id")
    team        Team     @relation(fields: [teamId], references: [id])
    role        TeamRole
    createdDate DateTime @default(now()) @map("created_date")

    @@unique([email, teamId])
}

enum FileRole {
    // There is only ever 1 owner per file which is stored on the file itself
    EDITOR
    VIEWER
}

model UserFileRole {
    id          Int      @id @default(autoincrement())
    userId      Int      @map("user_id")
    fileId      Int      @map("file_id")
    user        User     @relation(fields: [userId], references: [id])
    file        File     @relation(fields: [fileId], references: [id])
    role        FileRole
    createdDate DateTime @default(now()) @map("created_date")

    @@unique([userId, fileId])
}

model FileInvite {
    id          Int      @id @default(autoincrement())
    email       String
    fileId      Int      @map("file_id")
    file        File     @relation(fields: [fileId], references: [id])
    role        FileRole
    createdDate DateTime @default(now()) @map("created_date")

    @@unique([email, fileId])
}

// Future: folders
// model Folder {
//     id             Int      @id @default(autoincrement())
//     uuid           String   @unique @default(uuid())
//     name           String
//     createdDate    DateTime @default(now()) @map("created_date")
//     createdBy      User     @relation(fields: [createByUserId], references: [id])
//     createByUserId Int      @map("created_by_user_id")
//     team           Team?    @relation(fields: [teamId], references: [id])
// }
// enum FolderRole {}
// model UserFolderRole {}

model QFeedback {
    id           Int      @id @default(autoincrement())
    feedback     String
    // Additional context about the feedback source
    // If it's null, that's “In-app” feedback (which was the first kind we used)
    context      String?
    created_date DateTime @default(now())
    userId       Int?
    user         User?    @relation(fields: [userId], references: [id])
}

model AnalyticsAIChat {
    id          Int                      @id @default(autoincrement())
    userId      Int                      @map("user_id")
    user        User                     @relation(fields: [userId], references: [id])
    fileId      Int                      @map("file_id")
    file        File                     @relation(fields: [fileId], references: [id])
    chatId      String                   @unique @map("chat_id")
    source      AIChatSource
    messages    AnalyticsAIChatMessage[]
    createdDate DateTime                 @default(now()) @map("created_date")
    updatedDate DateTime                 @default(now()) @map("updated_date")

    @@index([chatId])
    @@index([userId])
    @@index([fileId])
    @@index([source])
    @@index([createdDate])
    @@index([userId, source, createdDate])
}

enum AIChatSource {
    AIAssistant                   @map("ai_assistant")
    AIAnalyst                     @map("ai_analyst")
    AIResearcher                  @map("ai_researcher")
    GetChatName                   @map("get_chat_name")
    GetFileName                   @map("get_file_name")
    CodeEditorCompletions         @map("code_editor_completions")
    GetUserPromptSuggestions      @map("get_user_prompt_suggestions")
    GetEmptyChatPromptSuggestions @map("get_empty_chat_prompt_suggestions")
    PDFImport                     @map("pdf_import")
    ModelRouter                   @map("model_router")
    WebSearch                     @map("web_search")
    OptimizePrompt                @map("optimize_prompt")
}

enum AIChatMessageType {
    userPrompt @map("user_prompt")
    toolResult @map("tool_result")
}

model AnalyticsAIChatMessage {
    id               Int                @id @default(autoincrement())
    chatId           Int                @map("chat_id")
    chat             AnalyticsAIChat    @relation(fields: [chatId], references: [id])
    model            String
    messageIndex     Int                @map("message_index")
    messageType      AIChatMessageType? @map("message_type")
    source           String?
    s3Key            String?            @map("s3_key")
    like             Boolean?
    undo             Boolean?
    codeRunError     String?            @map("code_run_error")
    responseError    String?            @map("response_error")
    inputTokens      Int?               @map("input_tokens")
    outputTokens     Int?               @map("output_tokens")
    cacheReadTokens  Int?               @map("cache_read_tokens")
    cacheWriteTokens Int?               @map("cache_write_tokens")
    createdDate      DateTime           @default(now()) @map("created_date")
    updatedDate      DateTime           @default(now()) @map("updated_date")

    @@unique([chatId, messageIndex], name: "chatId_messageIndex")
    @@index([chatId, messageType])
    @@index([chatId, messageIndex])
    @@index([chatId])
    @@index([model])
}

model AICost {
    id              Int            @id @default(autoincrement())
    userId          Int            @map("user_id")
    user            User           @relation(fields: [userId], references: [id])
    teamId          Int            @map("team_id")
    team            Team           @relation(fields: [teamId], references: [id])
    fileId          Int?           @map("file_id")
    file            File?          @relation(fields: [fileId], references: [id])
    cost            Float          // Cost in dollars
    model           String         // Model key (e.g., "gpt-4", "claude-3-5-sonnet")
    source          AIChatSource  // Source of the AI request
    inputTokens     Int            @default(0) @map("input_tokens")
    outputTokens    Int            @default(0) @map("output_tokens")
    cacheReadTokens Int            @default(0) @map("cache_read_tokens")
    cacheWriteTokens Int           @default(0) @map("cache_write_tokens")
    overageEnabled  Boolean        @default(false) @map("overage_enabled")
    createdDate     DateTime       @default(now()) @map("created_date")

    @@index([userId])
    @@index([teamId])
    @@index([userId, teamId, createdDate])
    @@index([createdDate])
    @@index([teamId, createdDate])
    @@index([teamId, createdDate, overageEnabled])
}

// Scheduled Tasks

enum ScheduledTaskStatus {
    ACTIVE
    INACTIVE
    DELETED
}

enum ScheduledTaskLogStatus {
    PENDING
    RUNNING
    COMPLETED
    FAILED
}

model ScheduledTask {
    id               Int                 @id @default(autoincrement())
    uuid             String              @unique @default(uuid())
    fileId           Int                 @map("file_id")
    file             File                @relation(fields: [fileId], references: [id])
    userId           Int                 @map("user_id")
    user             User                @relation(fields: [userId], references: [id])
    cronExpression   String              @map("cron_expression")
    nextRunTime      DateTime            @map("next_run_time")
    lastRunTime      DateTime?           @map("last_run_time")
    status           ScheduledTaskStatus @default(ACTIVE) @map("status")
    operations       Bytes
    createdDate      DateTime            @default(now()) @map("created_date")
    updatedDate      DateTime            @default(now()) @map("updated_date")
    ScheduledTaskLog ScheduledTaskLog[]

    @@index([uuid])
    @@index([fileId])
    @@index([userId])
}

model ScheduledTaskLog {
    id              Int                    @id @default(autoincrement())
    scheduledTaskId Int                    @map("scheduled_task_id")
    scheduledTask   ScheduledTask          @relation(fields: [scheduledTaskId], references: [id])
    runId           String                 @map("run_id")
    status          ScheduledTaskLogStatus @default(PENDING) @map("status")
    error           String?                @map("error")
    createdDate     DateTime               @default(now()) @map("created_date")

    @@index([scheduledTaskId])
    @@index([status])
    @@index([runId, createdDate(sort: Desc)])
    @@index([createdDate(sort: Desc)])
}

model UserBudgetLimit {
    id                    Int      @id @default(autoincrement())
    userId                Int      @map("user_id")
    user                  User     @relation(fields: [userId], references: [id])
    teamId                Int      @map("team_id")
    team                  Team     @relation(fields: [teamId], references: [id])
    monthlyBudgetLimit    Float    @map("monthly_budget_limit") // In dollars
    createdDate           DateTime @default(now()) @map("created_date")
    updatedDate           DateTime @default(now()) @map("updated_date")

    @@unique([userId, teamId])
    @@index([teamId])
}
